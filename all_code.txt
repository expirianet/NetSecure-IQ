
# ---- Builder ----
    FROM golang:1.24.4-bookworm AS builder
    ENV GOTOOLCHAIN=auto
    
    WORKDIR /app
    
    # Copy module files first (cache)
    COPY go.mod go.sum ./
    RUN go mod download
    
    # Copy the project
    COPY . .
    
    # Static build (binary at /bin/netsecure-iq)
    RUN CGO_ENABLED=0 GOOS=linux go build -o /bin/netsecure-iq .
    
    # ---- Runtime ----
    FROM debian:bookworm-slim
    
    # wg and docker CLI for the `wg genkey` and `docker exec` calls performed by the backend
    RUN apt-get update && apt-get install -y --no-install-recommends \
          wireguard-tools docker.io ca-certificates tzdata && \
        rm -rf /var/lib/apt/lists/*
    
    WORKDIR /app
    
    # Binary
    COPY --from=builder /bin/netsecure-iq /app/backend
    
    # Port exposed by main.go
    EXPOSE 8000
    
    # IMPORTANT: if the backend calls `docker exec`, mount the host socket at run:
    #   -v /var/run/docker.sock:/var/run/docker.sock
    CMD ["/app/backend"]
    
module netsecureiq/backend

go 1.24.4

require (
	github.com/apapsch/go-jsonmerge/v2 v2.0.0 // indirect
	github.com/golang-jwt/jwt/v5 v5.3.0 // indirect
	github.com/google/uuid v1.3.1 // indirect
	github.com/influxdata/influxdb-client-go/v2 v2.14.0 // indirect
	github.com/influxdata/line-protocol v0.0.0-20200327222509-2487e7298839 // indirect
	github.com/joho/godotenv v1.5.1 // indirect
	github.com/lib/pq v1.10.9 // indirect
	github.com/oapi-codegen/runtime v1.0.0 // indirect
	github.com/sethvargo/go-password v0.3.1 // indirect
	golang.org/x/crypto v0.41.0 // indirect
	golang.org/x/net v0.42.0 // indirect
	gopkg.in/alexcesaro/quotedprintable.v3 v3.0.0-20150716171945-2caba252f4dc // indirect
	gopkg.in/gomail.v2 v2.0.0-20160411212932-81ebce5c23df // indirect
)
github.com/RaveNoX/go-jsoncommentstrip v1.0.0/go.mod h1:78ihd09MekBnJnxpICcwzCMzGrKSKYe4AqU6PDYYpjk=
github.com/apapsch/go-jsonmerge/v2 v2.0.0 h1:axGnT1gRIfimI7gJifB699GoE/oq+F2MU7Dml6nw9rQ=
github.com/apapsch/go-jsonmerge/v2 v2.0.0/go.mod h1:lvDnEdqiQrp0O42VQGgmlKpxL1AP2+08jFMw88y4klk=
github.com/bmatcuk/doublestar v1.1.1/go.mod h1:UD6OnuiIn0yFxxA2le/rnRU1G4RaI4UvFv1sNto9p6w=
github.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
github.com/golang-jwt/jwt/v5 v5.3.0 h1:pv4AsKCKKZuqlgs5sUmn4x8UlGa0kEVt/puTpKx9vvo=
github.com/golang-jwt/jwt/v5 v5.3.0/go.mod h1:fxCRLWMO43lRc8nhHWY6LGqRcf+1gQWArsqaEUEa5bE=
github.com/google/uuid v1.3.1 h1:KjJaJ9iWZ3jOFZIf1Lqf4laDRCasjl0BCmnEGxkdLb4=
github.com/google/uuid v1.3.1/go.mod h1:TIyPZe4MgqvfeYDBFedMoGGpEw/LqOeaOT+nhxU+yHo=
github.com/influxdata/influxdb-client-go/v2 v2.14.0 h1:AjbBfJuq+QoaXNcrova8smSjwJdUHnwvfjMF71M1iI4=
github.com/influxdata/influxdb-client-go/v2 v2.14.0/go.mod h1:Ahpm3QXKMJslpXl3IftVLVezreAUtBOTZssDrjZEFHI=
github.com/influxdata/line-protocol v0.0.0-20200327222509-2487e7298839 h1:W9WBk7wlPfJLvMCdtV4zPulc4uCPrlywQOmbFOhgQNU=
github.com/influxdata/line-protocol v0.0.0-20200327222509-2487e7298839/go.mod h1:xaLFMmpvUxqXtVkUJfg9QmT88cDaCJ3ZKgdZ78oO8Qo=
github.com/joho/godotenv v1.5.1 h1:7eLL/+HRGLY0ldzfGMeQkb7vMd0as4CfYvUVzLqw0N0=
github.com/joho/godotenv v1.5.1/go.mod h1:f4LDr5Voq0i2e/R5DDNOoa2zzDfwtkZa6DnEwAbqwq4=
github.com/juju/gnuflag v0.0.0-20171113085948-2ce1bb71843d/go.mod h1:2PavIy+JPciBPrBUjwbNvtwB6RQlve+hkpll6QSNmOE=
github.com/lib/pq v1.10.9 h1:YXG7RB+JIjhP29X+OtkiDnYaXQwpS4JEWq7dtCCRUEw=
github.com/lib/pq v1.10.9/go.mod h1:AlVN5x4E4T544tWzH6hKfbfQvm3HdbOxrmggDNAPY9o=
github.com/oapi-codegen/runtime v1.0.0 h1:P4rqFX5fMFWqRzY9M/3YF9+aPSPPB06IzP2P7oOxrWo=
github.com/oapi-codegen/runtime v1.0.0/go.mod h1:LmCUMQuPB4M/nLXilQXhHw+BLZdDb18B34OO356yJ/A=
github.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=
github.com/sethvargo/go-password v0.3.1 h1:WqrLTjo7X6AcVYfC6R7GtSyuUQR9hGyAj/f1PYQZCJU=
github.com/sethvargo/go-password v0.3.1/go.mod h1:rXofC1zT54N7R8K/h1WDUdkf9BOx5OptoxrMBcrXzvs=
github.com/spkg/bom v0.0.0-20160624110644-59b7046e48ad/go.mod h1:qLr4V1qq6nMqFKkMo8ZTx3f+BZEkzsRUY10Xsm2mwU0=
github.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=
github.com/stretchr/testify v1.3.0/go.mod h1:M5WIy9Dh21IEIfnGCwXGc5bZfKNJtfHm1UVUgZn+9EI=
golang.org/x/crypto v0.41.0 h1:WKYxWedPGCTVVl5+WHSSrOBT0O8lx32+zxmHxijgXp4=
golang.org/x/crypto v0.41.0/go.mod h1:pO5AFd7FA68rFak7rOAGVuygIISepHftHnr8dr6+sUc=
golang.org/x/net v0.42.0 h1:jzkYrhi3YQWD6MLBJcsklgQsoAcw89EcZbJw8Z614hs=
golang.org/x/net v0.42.0/go.mod h1:FF1RA5d3u7nAYA4z2TkclSCKh68eSXtiFwcWQpPXdt8=
gopkg.in/alexcesaro/quotedprintable.v3 v3.0.0-20150716171945-2caba252f4dc h1:2gGKlE2+asNV9m7xrywl36YYNnBG5ZQ0r/BOOxqPpmk=
gopkg.in/alexcesaro/quotedprintable.v3 v3.0.0-20150716171945-2caba252f4dc/go.mod h1:m7x9LTH6d71AHyAX77c9yqWCCa3UKHcVEj9y7hAtKDk=
gopkg.in/gomail.v2 v2.0.0-20160411212932-81ebce5c23df h1:n7WqCuqOuCbNr617RXOY0AWRXxgwEyPp2z+p0+hgMuE=
gopkg.in/gomail.v2 v2.0.0-20160411212932-81ebce5c23df/go.mod h1:LRQQ+SO6ZHR7tOkpBDuZnXENFzX8qRjMDMyPD6BRkCw=
package main

import (
	"bytes"
	"context"
	"database/sql"
	"encoding/json"
	"fmt"
	"io"
	"log"
	"net"
	"net/http"
	"os"
	"os/exec"
	"strings"
	"time"

	"github.com/joho/godotenv"

	influxdb2 "github.com/influxdata/influxdb-client-go/v2"

	"github.com/golang-jwt/jwt/v5"
	_ "github.com/lib/pq"
	"github.com/sethvargo/go-password/password"
	"golang.org/x/crypto/bcrypt"
	"gopkg.in/gomail.v2"
)

// ======================================================
// Globals (valeurs affectÃ©es dans main() aprÃ¨s Load .env)
// ======================================================
var (
	db          *sql.DB
	jwtSecret   []byte
	influxToken string
	influxBucket string
	influxOrg   string
	influxURL   string
	influxClient influxdb2.Client
)

// ======================
// Request/Model structs
// ======================
type RegisterRequest struct {
	Email string `json:"email"`
}

type LoginRequest struct {
	Email    string `json:"email"`
	Password string `json:"password"`
}

type OrganizationRequest struct {
	Name          string `json:"name"`
	Address       string `json:"address"`
	VATNumber     string `json:"vat_number"`
	State         string `json:"state"`
	City          string `json:"city"`
	ZipCode       string `json:"zip_code"`
	ContactEmail  string `json:"contact_email"`
	PecEmail      string `json:"pec_email"`
	SdiCode       string `json:"sdi_code"`
	ContactPhone  string `json:"contact_phone"`
	PersonnelInfo string `json:"personnel_info"`
	UserID        string `json:"user_id"`
}

type RouterStatus struct {
	MAC   string `json:"mac"`
	Value string `json:"value"`
	Time  string `json:"time"`
}

type MikroTikData struct {
	MAC    string `json:"mac"`
	Status string `json:"status"` // "online", "offline", etc.
}

type CreateUserRequest struct {
	Email          string  `json:"email"`
	FirstName      string  `json:"first_name"`
	LastName       string  `json:"last_name"`
	OrganizationID *string `json:"organization_id"`
	Role           string  `json:"role"`
}

type MikroTikRegisterRequest struct {
	MAC    string  `json:"mac"`
	SiteID *string `json:"site_id"` // Optional for now
}

// =================================
// Bootstrap helpers (env + clients)
// =================================

func loadEnv() {
	// Essaie d'abord ./.env puis le chemin custom existant
	if err := godotenv.Load(".env"); err != nil {
		if err2 := godotenv.Load("../../config/backend_env/backend.env"); err2 != nil {
			log.Println("âš ï¸ .env not found in standard or custom path â€” using system env vars only")
		} else {
			log.Println("âœ… Loaded env from ../../config/backend_env/backend.env")
		}
	} else {
		log.Println("âœ… Loaded env from .env")
	}
}

func initPostgres() {
	host := os.Getenv("POSTGRES_HOST")
	port := os.Getenv("POSTGRES_PORT")
	user := os.Getenv("POSTGRES_USER")
	pass := os.Getenv("POSTGRES_PASSWORD")
	dbname := os.Getenv("POSTGRES_DB")

	if host == "" || port == "" || user == "" || pass == "" || dbname == "" {
		log.Println("âš ï¸ Missing PostgreSQL env vars: POSTGRES_HOST/PORT/USER/PASSWORD/DB â€” DB features will be disabled")
		return
	}

	dsn := fmt.Sprintf(
		"host=%s port=%s user=%s password=%s dbname=%s sslmode=disable",
		host, port, user, pass, dbname,
	)

	var err error
	db, err = sql.Open("postgres", dsn)
	if err != nil {
		log.Println("âŒ Failed to open DB:", err)
		return
	}
	if err := db.Ping(); err != nil {
		log.Println("âŒ Failed to connect to DB:", err)
		db = nil
		return
	}
	log.Println("âœ… Connected to PostgreSQL successfully")
}

func initInflux() {
	influxToken = os.Getenv("INFLUXDB_TOKEN")
	influxBucket = os.Getenv("INFLUXDB_BUCKET")
	influxOrg = os.Getenv("INFLUXDB_ORG")
	influxURL = os.Getenv("INFLUXDB_URL")

	if influxToken == "" || influxBucket == "" || influxOrg == "" || influxURL == "" {
		log.Println("âš ï¸ InfluxDB env vars missing or incomplete â€” Influx features will be disabled")
		return
	}
	influxClient = influxdb2.NewClient(influxURL, influxToken)
	log.Println("âœ… InfluxDB client initialized")
}

// Quick guards to avoid panics if DB/Influx not initialized
func requireDB(w http.ResponseWriter) bool {
	if db == nil {
		http.Error(w, "Database not initialized", http.StatusServiceUnavailable)
		return false
	}
	return true
}
func requireInflux(w http.ResponseWriter) bool {
	if influxClient == nil {
		http.Error(w, "InfluxDB not initialized", http.StatusServiceUnavailable)
		return false
	}
	return true
}

// =====
// main
// =====
func main() {
	loadEnv()

	// Charger secrets aprÃ¨s loadEnv()
	jwtSecret = []byte(os.Getenv("JWT_SECRET"))
	if len(jwtSecret) == 0 {
		log.Println("âš ï¸ JWT_SECRET is not set â€” JWT will not work properly")
	}

	initPostgres()
	initInflux()

	// Routes
	http.HandleFunc("/api/register", withCORS(handleRegister))
	http.HandleFunc("/api/login", withCORS(handleLogin))
	http.HandleFunc("/api/ping", withCORS(handlePing))
	http.HandleFunc("/api/protected", withCORS(jwtMiddleware(handleProtected)))
	http.HandleFunc("/api/data/routers", withCORS(jwtMiddleware(handleRouters)))
	http.HandleFunc("/api/complete-organization", withCORS(handleCompleteOrganization))
	http.HandleFunc("/api/users", withCORS(handleCreateUser))
	http.HandleFunc("/api/mikrotik/resource", withCORS(handleMikrotikResource))
	http.HandleFunc("/api/mikrotik/dump", withCORS(handleMikrotikDump))
	http.HandleFunc("/api/mikrotik/preregister", withCORS(handleMikrotikPreRegister))
	http.HandleFunc("/api/mikrotik/list", withCORS(handleMikrotikList))
	http.HandleFunc("/api/mikrotik/test", withCORS(handleMikrotikTest))
	http.HandleFunc("/api/mikrotik/disable", withCORS(handleMikrotikDisable))
	http.HandleFunc("/api/mikrotik/enable", withCORS(handleMikrotikEnable))
	http.HandleFunc("/api/mikrotik/associate", withCORS(handleMikrotikAssociate))
	http.HandleFunc("/api/mikrotik", withCORS(handleMikrotikDelete)) // DELETE

	// Logs startup
	masked := "<empty>"
	if len(jwtSecret) > 0 {
		masked = fmt.Sprintf("â€¢â€¢â€¢(%d bytes)", len(jwtSecret))
	}
	fmt.Println("ðŸ” JWT Secret:", masked)
	fmt.Println("ðŸ“¦ Influx URL:", influxURL)
	fmt.Println("ðŸš€ Server started at http://localhost:8000 (even if DB/Influx are down)")

	log.Fatal(http.ListenAndServe(":8000", nil))
}

// =======
// Helpers
// =======
func withCORS(h http.HandlerFunc) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		// Log request
		fmt.Printf("ðŸ“¡ [%s] %s %s\n", time.Now().Format("15:04:05"), r.Method, r.URL.Path)
		fmt.Println("ðŸ“¦ Headers:", r.Header)

		origin := r.Header.Get("Origin")
		if origin == "" {
			origin = "*"
		}

		// Set CORS headers
		w.Header().Set("Access-Control-Allow-Origin", origin)
		w.Header().Set("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS")
		w.Header().Set("Access-Control-Allow-Headers", "Content-Type, Authorization, X-Requested-With")
		w.Header().Set("Access-Control-Allow-Credentials", "true")
		w.Header().Set("Access-Control-Max-Age", "86400") // 24 hours

		// Handle preflight requests
		if r.Method == "OPTIONS" {
			w.WriteHeader(http.StatusOK)
			return
		}

		// Call the next handler
		h(w, r)
	}
}

// ==================
// Auth & User Routes
// ==================
func handleRegister(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodPost {
		http.Error(w, "Only POST allowed", http.StatusMethodNotAllowed)
		return
	}
	if !requireDB(w) {
		return
	}

	var req RegisterRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		http.Error(w, "Invalid request body", http.StatusBadRequest)
		return
	}
	if req.Email == "" {
		http.Error(w, "Email is required", http.StatusBadRequest)
		return
	}

	generatedPassword, err := password.Generate(16, 4, 4, false, false)
	if err != nil {
		http.Error(w, "Failed to generate password", http.StatusInternalServerError)
		return
	}
	hash, err := bcrypt.GenerateFromPassword([]byte(generatedPassword), bcrypt.DefaultCost)
	if err != nil {
		http.Error(w, "Failed to hash password", http.StatusInternalServerError)
		return
	}

	_, err = db.Exec(`INSERT INTO users (email, password_hash, role_id) VALUES ($1, $2, $3)`, req.Email, string(hash), 2)
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		_ = json.NewEncoder(w).Encode(map[string]string{
			"error": "Database insert failed: " + err.Error(),
		})
		return
	}

	m := gomail.NewMessage()
	m.SetHeader("From", "NetSecure IQ <noreply@netsecure.test>")
	m.SetHeader("To", req.Email)
	m.SetHeader("Subject", "Your NetSecure IQ Access")
	m.SetBody("text/plain", fmt.Sprintf(`Hello,

Welcome to NetSecure IQ!
Your temporary password is:

%s

Please log in and complete your profile.

â€“ NetSecure IQ Team`, generatedPassword))

	d := gomail.NewDialer("sandbox.smtp.mailtrap.io", 2525, "a7579402169dd8", "6644803192d28b")
	if err := d.DialAndSend(m); err != nil {
		log.Println("Failed to send email:", err)
	}

	_ = json.NewEncoder(w).Encode(map[string]string{
		"message": "User registered successfully. Check your email.",
	})
}

func handleLogin(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodPost {
		http.Error(w, "Only POST allowed", http.StatusMethodNotAllowed)
		return
	}
	if !requireDB(w) {
		return
	}

	var req LoginRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		http.Error(w, "Invalid request body", http.StatusBadRequest)
		return
	}

	var hash, roleName string
	var userID, orgID sql.NullString
	err := db.QueryRow(`
		SELECT u.id, u.password_hash, r.name, u.organization_id
		FROM users u
		JOIN roles r ON u.role_id = r.id
		WHERE u.email = $1
	`, req.Email).Scan(&userID, &hash, &roleName, &orgID)

	if err == sql.ErrNoRows || bcrypt.CompareHashAndPassword([]byte(hash), []byte(req.Password)) != nil {
		http.Error(w, "Invalid email or password", http.StatusUnauthorized)
		return
	} else if err != nil {
		http.Error(w, "Database error: "+err.Error(), http.StatusInternalServerError)
		return
	}

	// Create JWT token
	token := jwt.NewWithClaims(jwt.SigningMethodHS256, jwt.MapClaims{
		"email":   req.Email,
		"role":    roleName,
		"user_id": userID.String,
		"exp":     jwt.NewNumericDate(time.Now().Add(24 * time.Hour)),
	})
	tokenString, err := token.SignedString(jwtSecret)
	if err != nil {
		http.Error(w, "Failed to generate token", http.StatusInternalServerError)
		return
	}

	// Final response
	resp := map[string]interface{}{
		"message": "Login successful",
		"token":   tokenString,
		"role":    roleName,
		"user_id": userID.String,
	}
	if orgID.Valid {
		resp["organization_id"] = orgID.String
	} else {
		resp["organization_id"] = nil
	}

	_ = json.NewEncoder(w).Encode(resp)
}

func handleProtected(w http.ResponseWriter, r *http.Request) {
	authHeader := r.Header.Get("Authorization")
	if authHeader == "" {
		http.Error(w, "Missing Authorization header", http.StatusUnauthorized)
		return
	}

	tokenString := strings.TrimPrefix(authHeader, "Bearer ")
	token, err := jwt.Parse(tokenString, func(token *jwt.Token) (interface{}, error) {
		if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {
			return nil, fmt.Errorf("unexpected signing method")
		}
		return jwtSecret, nil
	})
	if err != nil || !token.Valid {
		http.Error(w, "Invalid token", http.StatusUnauthorized)
		return
	}

	claims, ok := token.Claims.(jwt.MapClaims)
	if !ok {
		http.Error(w, "Invalid token claims", http.StatusUnauthorized)
		return
	}
	_ = json.NewEncoder(w).Encode(claims)
}

func jwtMiddleware(next http.HandlerFunc) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		authHeader := r.Header.Get("Authorization")
		if authHeader == "" {
			http.Error(w, "Missing Authorization header", http.StatusUnauthorized)
			return
		}
		const prefix = "Bearer "
		if len(authHeader) <= len(prefix) || authHeader[:len(prefix)] != prefix {
			http.Error(w, "Invalid Authorization header format", http.StatusUnauthorized)
			return
		}

		tokenString := authHeader[len(prefix):]
		token, err := jwt.Parse(tokenString, func(token *jwt.Token) (interface{}, error) {
			if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {
				return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])
			}
			return jwtSecret, nil
		})
		if err != nil || !token.Valid {
			http.Error(w, "Invalid token", http.StatusUnauthorized)
			return
		}
		next(w, r)
	}
}

// ==================
// Influx data routes
// ==================
func handlePing(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodPost {
		http.Error(w, "Only POST allowed", http.StatusMethodNotAllowed)
		return
	}
	if !requireInflux(w) {
		return
	}

	var data MikroTikData
	if err := json.NewDecoder(r.Body).Decode(&data); err != nil {
		http.Error(w, "Invalid JSON body", http.StatusBadRequest)
		return
	}
	fmt.Printf("ðŸ“¡ Ping received: %+v\n", data)

	writeAPI := influxClient.WriteAPIBlocking(influxOrg, influxBucket)
	p := influxdb2.NewPointWithMeasurement("device_status").
		AddTag("mac", data.MAC).
		AddField("status", data.Status).
		SetTime(time.Now())

	if err := writeAPI.WritePoint(context.Background(), p); err != nil {
		http.Error(w, "Failed to write to InfluxDB: "+err.Error(), http.StatusInternalServerError)
		return
	}
	w.WriteHeader(http.StatusNoContent)
}

func handleRouters(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodGet {
		http.Error(w, "Only GET allowed", http.StatusMethodNotAllowed)
		return
	}
	if !requireInflux(w) {
		return
	}

	queryAPI := influxClient.QueryAPI(influxOrg)
	query := fmt.Sprintf(`
		from(bucket: "%s")
			|> range(start: -7d)
			|> filter(fn: (r) => r._measurement == "device_status")
			|> filter(fn: (r) => r._field == "status")
			|> last()
	`, influxBucket)

	result, err := queryAPI.Query(context.Background(), query)
	if err != nil {
		http.Error(w, "InfluxDB query failed: "+err.Error(), http.StatusInternalServerError)
		return
	}

	var output []RouterStatus
	for result.Next() {
		record := result.Record()
		mac := record.ValueByKey("mac")
		if mac == nil {
			continue
		}
		output = append(output, RouterStatus{
			MAC:   fmt.Sprintf("%v", mac),
			Value: fmt.Sprintf("%v", record.Value()),
			Time:  record.Time().Format(time.RFC3339),
		})
	}
	if result.Err() != nil {
		http.Error(w, "Influx parse error: "+result.Err().Error(), http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	_ = json.NewEncoder(w).Encode(output)
}

// ===========================
// Organization & User routes
// ===========================
func handleCompleteOrganization(w http.ResponseWriter, r *http.Request) {
	// Set content type for the response
	w.Header().Set("Content-Type", "application/json")

	if r.Method != http.MethodPost {
		http.Error(w, `{"error": "Only POST method is allowed"}`, http.StatusMethodNotAllowed)
		return
	}

	if !requireDB(w) {
		return
	}

	var req OrganizationRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		http.Error(w, `{"error": "Invalid JSON body"}`, http.StatusBadRequest)
		return
	}

	// Log the received request for debugging
	fmt.Printf("ðŸ“¥ Received OrganizationRequest: %+v\n", req)

	// Validate required fields
	if req.Name == "" || req.VATNumber == "" || req.UserID == "" {
		http.Error(w, `{"error": "Missing required fields"}`, http.StatusBadRequest)
		return
	}

	var orgID string
	err := db.QueryRow(`
		INSERT INTO organizations (
			name, address, vat_number, state, city, zip_code,
			contact_email, pec_email, sdi_code, contact_phone,
			personnel_info, created_at, updated_at
		)
		VALUES ($1, $2, $3, $4, $5, $6,
				$7, $8, $9, $10,
				$11, now(), now())
		RETURNING id
	`, req.Name, req.Address, req.VATNumber, req.State, req.City, req.ZipCode,
		req.ContactEmail, req.PecEmail, req.SdiCode, req.ContactPhone,
		req.PersonnelInfo).Scan(&orgID)

	if err != nil {
		errMsg := fmt.Sprintf(`{"error": "Failed to insert organization: %v"}`, err.Error())
		http.Error(w, errMsg, http.StatusInternalServerError)
		return
	}

	_, err = db.Exec(`UPDATE users SET organization_id = $1, updated_at = now() WHERE id = $2`, orgID, req.UserID)
	if err != nil {
		errMsg := fmt.Sprintf(`{"error": "Failed to update user with organization: %v"}`, err.Error())
		http.Error(w, errMsg, http.StatusInternalServerError)
		return
	}

	// Return success response
	response := map[string]interface{}{
		"success": true,
		"message": "Organization created and linked successfully",
		"organization_id": orgID,
	}

	if err := json.NewEncoder(w).Encode(response); err != nil {
		http.Error(w, `{"error": "Failed to encode response"}`, http.StatusInternalServerError)
	}
}

func handleCreateUser(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodPost {
		http.Error(w, "Only POST allowed", http.StatusMethodNotAllowed)
		return
	}
	if !requireDB(w) {
		return
	}

	var req CreateUserRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		http.Error(w, "Invalid JSON body", http.StatusBadRequest)
		return
	}
	if req.Email == "" || req.FirstName == "" || req.LastName == "" {
		http.Error(w, "Missing required fields", http.StatusBadRequest)
		return
	}

	// Determine role ID from string
	var roleID int
	switch req.Role {
	case "admin":
		roleID = 1
	case "operator":
		roleID = 2
	default:
		roleID = 3 // default User
	}

	// Generate and hash password
	generatedPassword, err := password.Generate(16, 4, 4, false, false)
	if err != nil {
		http.Error(w, "Failed to generate password", http.StatusInternalServerError)
		return
	}
	hash, err := bcrypt.GenerateFromPassword([]byte(generatedPassword), bcrypt.DefaultCost)
	if err != nil {
		http.Error(w, "Failed to hash password", http.StatusInternalServerError)
		return
	}

	// Insert user
	_, err = db.Exec(`
    INSERT INTO users (email, password_hash, role_id, first_name, last_name, organization_id, created_at, updated_at)
    VALUES ($1, $2, $3, $4, $5, $6, now(), now())
  `, req.Email, string(hash), roleID, req.FirstName, req.LastName, req.OrganizationID)
	if err != nil {
		http.Error(w, "Database insert failed: "+err.Error(), http.StatusInternalServerError)
		return
	}

	// Send email
	m := gomail.NewMessage()
	m.SetHeader("From", "NetSecure IQ <noreply@netsecure.test>")
	m.SetHeader("To", req.Email)
	m.SetHeader("Subject", "Your NetSecure IQ Account")
	m.SetBody("text/plain", fmt.Sprintf(`Hello %s,

Your account has been created in NetSecure IQ.
Login Email: %s
Your role is: %s
Temporary Password: %s

Please log in and change your password as soon as possible.

â€“ NetSecure IQ Team`, req.FirstName, req.Email, req.Role, generatedPassword))

	d := gomail.NewDialer("sandbox.smtp.mailtrap.io", 2525, "a7579402169dd8", "6644803192d28b")
	if err := d.DialAndSend(m); err != nil {
		log.Println("Failed to send email:", err)
	}

	_ = json.NewEncoder(w).Encode(map[string]string{
		"message": "User created and password emailed",
	})
}

// ============================================
// MikroTik (resource + dump via MikroTik REST)
// ============================================
func getMikrotikSystemResource() (map[string]interface{}, error) {
	host := os.Getenv("MIKROTIK_HOST")
	port := os.Getenv("MIKROTIK_PORT")
	user := os.Getenv("MIKROTIK_USER")
	pass := os.Getenv("MIKROTIK_PASSWORD")

	if host == "" || port == "" || user == "" || pass == "" {
		return nil, fmt.Errorf("missing MikroTik REST API credentials in environment variables")
	}

	url := fmt.Sprintf("http://%s:%s/rest/system/resource", host, port)
	req, err := http.NewRequest("GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to create HTTP request: %w", err)
	}
	req.SetBasicAuth(user, pass)

	client := &http.Client{Timeout: 5 * time.Second}
	resp, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("failed to reach MikroTik REST API: %w", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("unexpected status code: %d", resp.StatusCode)
	}

	var data map[string]interface{}
	if err := json.NewDecoder(resp.Body).Decode(&data); err != nil {
		return nil, fmt.Errorf("failed to decode JSON: %w", err)
	}
	return data, nil
}

func handleMikrotikResource(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodGet {
		http.Error(w, "Only GET allowed", http.StatusMethodNotAllowed)
		return
	}

	data, err := getMikrotikSystemResource()
	if err != nil {
		http.Error(w, "Error: "+err.Error(), http.StatusInternalServerError)
		return
	}

	fmt.Println("ðŸ“¦ MikroTik REST API Response:")
	prettyJSON, _ := json.MarshalIndent(data, "", "  ")
	fmt.Println(string(prettyJSON))

	w.Header().Set("Content-Type", "application/json")
	_ = json.NewEncoder(w).Encode(data)
}

func getAllMikrotikMetricsAsText() (string, error) {
	host := os.Getenv("MIKROTIK_HOST")
	port := os.Getenv("MIKROTIK_PORT")
	user := os.Getenv("MIKROTIK_USER")
	pass := os.Getenv("MIKROTIK_PASSWORD")

	if host == "" || port == "" || user == "" || pass == "" {
		return "", fmt.Errorf("missing MikroTik REST API credentials")
	}

	baseURL := fmt.Sprintf("http://%s:%s/rest", host, port)
	endpoints := map[string]string{
		"System Resource":             "/system/resource",
		"Interfaces":                  "/interface",
		"ARP Table":                   "/ip/arp",
		"Firewall Service Ports":      "/ip/firewall/service-port",
		"Firewall Connections":        "/ip/firewall/connection",
		"Wireless Registration Table": "/interface/wireless/registration-table",
	}

	var builder strings.Builder
	client := &http.Client{Timeout: 5 * time.Second}

	for label, ep := range endpoints {
		url := baseURL + ep
		req, err := http.NewRequest("GET", url, nil)
		if err != nil {
			builder.WriteString(fmt.Sprintf("Section: %s\nError: failed to build request: %v\n\n", label, err))
			continue
		}
		req.SetBasicAuth(user, pass)

		resp, err := client.Do(req)
		if err != nil {
			builder.WriteString(fmt.Sprintf("Section: %s\nError: %v\n\n", label, err))
			continue
		}
		defer resp.Body.Close()

		body, _ := io.ReadAll(resp.Body)

		builder.WriteString(fmt.Sprintf("===== %s =====\n", label))

		var prettyJSON bytes.Buffer
		if json.Indent(&prettyJSON, body, "", "  ") == nil {
			builder.Write(prettyJSON.Bytes())
		} else {
			builder.Write(body)
		}
		builder.WriteString("\n\n")
	}

	return builder.String(), nil
}

func handleMikrotikDump(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodGet {
		http.Error(w, "Only GET allowed", http.StatusMethodNotAllowed)
		return
	}

	result, err := getAllMikrotikMetricsAsText()
	if err != nil {
		http.Error(w, "Error: "+err.Error(), http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "text/plain")
	_, _ = w.Write([]byte(result))
}

// -------------------------------------------------
// WireGuard pre-registration for MikroTik routers
// -------------------------------------------------
var (
	wireguardSubnet = "10.100.99.0/24"
	startOffset     = 10
)

func generateRealWGKeys() (string, string, error) {
	privateCmd := exec.Command("wg", "genkey")
	privateOut := &bytes.Buffer{}
	privateCmd.Stdout = privateOut
	if err := privateCmd.Run(); err != nil {
		return "", "", fmt.Errorf("wg genkey failed: %v", err)
	}
	privateKey := bytes.TrimSpace(privateOut.Bytes())

	pubCmd := exec.Command("wg", "pubkey")
	pubCmd.Stdin = bytes.NewReader(privateKey)
	pubOut := &bytes.Buffer{}
	pubCmd.Stdout = pubOut
	if err := pubCmd.Run(); err != nil {
		return "", "", fmt.Errorf("wg pubkey failed: %v", err)
	}
	publicKey := bytes.TrimSpace(pubOut.Bytes())

	return string(privateKey), string(publicKey), nil
}

func getNextAvailableIP() (string, error) {
	_, ipnet, err := net.ParseCIDR(wireguardSubnet)
	if err != nil {
		return "", fmt.Errorf("invalid subnet: %w", err)
	}
	baseIP := ipnet.IP.To4()
	if baseIP == nil {
		return "", fmt.Errorf("not a valid IPv4 subnet")
	}

	if db == nil {
		return "", fmt.Errorf("database not initialized")
	}

	rows, err := db.Query(`SELECT vpn_internal_ip FROM mikrotik_routers`)
	if err != nil {
		return "", fmt.Errorf("failed to query IPs from database: %w", err)
	}
	defer rows.Close()

	usedIPs := make(map[string]bool)
	for rows.Next() {
		var ipStr string
		if err := rows.Scan(&ipStr); err == nil && ipStr != "" {
			usedIPs[ipStr] = true
		}
	}

	for i := startOffset; i < 255; i++ {
		candidateIP := net.IPv4(baseIP[0], baseIP[1], baseIP[2], byte(i)).String()
		if !usedIPs[candidateIP] {
			return candidateIP, nil
		}
	}
	return "", fmt.Errorf("no available IPs in subnet")
}

func MikroTikPreRegister(mac string) (map[string]string, error) {
	fmt.Println("ðŸ”§ Starting MikroTik registration for MAC:", mac)

	privateKey, publicKey, err := generateRealWGKeys()
	if err != nil {
		return nil, fmt.Errorf("key generation failed: %w", err)
	}
	fmt.Println("âœ… WireGuard Keys Generated")
	fmt.Println("ðŸ”‘ Private Key:", privateKey)
	fmt.Println("ðŸ” Public Key:", publicKey)

	ip, err := getNextAvailableIP()
	if err != nil {
		return nil, fmt.Errorf("IP allocation failed: %w", err)
	}
	fmt.Println("âœ… Assigned IP:", ip)

	mikrotikConfig := generateMikroTikConfig(privateKey, ip)
	fmt.Println("ðŸ“„ MikroTik Configuration Script:\n", mikrotikConfig)

	serverConf := fmt.Sprintf(`[Peer]
PublicKey = %s
AllowedIPs = %s/32`, publicKey, ip)
	fmt.Println("ðŸ“„ WireGuard Peer (Server) Config:\n", serverConf)

	_, err = db.Exec(`
		INSERT INTO mikrotik_routers (
			id, site_id, mac_address,
			vpn_private_key, vpn_public_key, vpn_internal_ip,
			firmware_version, model, serial_number,
			provisioning_status, created_at, updated_at
		)
		VALUES (
			gen_random_uuid(), NULL, $1,
			$2, $3, $4,
			NULL, 'unknown', 'unknown',
			'PENDING', now(), now()
		)
	`, mac, privateKey, publicKey, ip)
	if err != nil {
		return nil, fmt.Errorf("database insert failed: %w", err)
	}

	result := map[string]string{
		"internal_ip":     ip,
		"private_key":     privateKey,
		"public_key":      publicKey,
		"mikrotik_config": mikrotikConfig,
		"server_peer":     serverConf,
	}

	if err := addWireGuardPeer(publicKey, ip); err != nil {
		log.Println("âš ï¸ Could not add peer to WireGuard:", err)
	}
	return result, nil
}

func generateMikroTikConfig(privateKey, ip string) string {
	return fmt.Sprintf(`/interface wireguard add name=wg1 private-key="%s"
/ip address add address=%s/32 interface=wg1
/interface wireguard peers add allowed-address=0.0.0.0/0 endpoint-address=NETSECURE_PUBLIC_IP endpoint-port=51820 interface=wg1 public-key=NETSECURE_PUBLIC_KEY`,
		privateKey, ip)
}

// =====================
// MikroTik HTTP routes
// =====================
const wgContainer = "netsecure-iq-wireguard-1"

type MikroTikRow struct {
	MAC    string
	PubKey string
	IP     string
	SiteID sql.NullString
	Status string // provisioning_status
}

func getRouterByMAC(mac string) (*MikroTikRow, error) {
	if db == nil {
		return nil, fmt.Errorf("database not initialized")
	}
	row := db.QueryRow(`
		SELECT mac_address, vpn_public_key, vpn_internal_ip, 
		       COALESCE(provisioning_status,'PENDING') AS provisioning_status,
		       site_id::text
		FROM mikrotik_routers WHERE mac_address = $1
	`, mac)
	var r MikroTikRow
	var siteID *string
	if err := row.Scan(&r.MAC, &r.PubKey, &r.IP, &r.Status, &siteID); err != nil {
		return nil, err
	}
	if siteID != nil {
		r.SiteID = sql.NullString{String: *siteID, Valid: true}
	}
	return &r, nil
}

func listRouters() ([]MikroTikRow, error) {
	if db == nil {
		return nil, fmt.Errorf("database not initialized")
	}
	rows, err := db.Query(`
		SELECT mac_address, vpn_public_key, vpn_internal_ip,
		       COALESCE(provisioning_status,'PENDING') AS provisioning_status,
		       site_id::text
		FROM mikrotik_routers
		ORDER BY created_at DESC
	`)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var out []MikroTikRow
	for rows.Next() {
		var r MikroTikRow
		var siteID *string
		if err := rows.Scan(&r.MAC, &r.PubKey, &r.IP, &r.Status, &siteID); err != nil {
			return nil, err
		}
		if siteID != nil {
			r.SiteID = sql.NullString{String: *siteID, Valid: true}
		}
		out = append(out, r)
	}
	return out, nil
}

func addWireGuardPeer(publicKey, ip string) error {
	cmd := exec.Command("docker", "exec", wgContainer,
		"wg", "set", "wg0",
		"peer", publicKey,
		"allowed-ips", ip+"/32")
	if out, err := cmd.CombinedOutput(); err != nil {
		return fmt.Errorf("wg add peer failed: %v\nOutput: %s", err, string(out))
	}

	script := fmt.Sprintf(`
if ! grep -q "PublicKey = %s" /config/wg_confs/wg0.conf; then
  cat <<'EOF' >> /config/wg_confs/wg0.conf

[Peer]
PublicKey = %s
AllowedIPs = %s/32
EOF
fi
`, publicKey, publicKey, ip)

	appendCmd := exec.Command("docker", "exec", wgContainer, "sh", "-c", script)
	if out, err := appendCmd.CombinedOutput(); err != nil {
		return fmt.Errorf("failed to append peer to /config/wg_confs/wg0.conf: %v\nOutput: %s", err, string(out))
	}
	return nil
}

func removeWireGuardPeer(publicKey string) error {
	cfgPath := "/config/wg_confs/wg0.conf"

	{
		cmd := exec.Command("docker", "exec", wgContainer,
			"wg", "set", "wg0", "peer", publicKey, "remove")
		if out, err := cmd.CombinedOutput(); err != nil {
			return fmt.Errorf("wg remove peer failed: %v\nOutput: %s", err, string(out))
		}
	}

	script := fmt.Sprintf(`
set -e
CFG="%s"
PUB="%s"

awk -v key="$PUB" '
function flush() {
  if (buf_len > 0) {
    if (keep) {
      for (i=1;i<=buf_len;i++) print buf[i];
    }
    delete buf; buf_len=0; keep=1; inpeer=0;
  }
}
BEGIN { buf_len=0; keep=1; inpeer=0 }
/^\[Peer\]/ { flush(); inpeer=1 } 
{
  buf[++buf_len]=$0
  if ($0 ~ /^[[:space:]]*PublicKey[[:space:]]*=/) {
    line=$0
    sub(/^[[:space:]]*PublicKey[[:space:]]*=[[:space:]]*/, "", line)
    sub(/[[:space:]]+$/, "", line)
    if (line == key) { keep=0 }
  }
}
END { flush() }
' "$CFG" > "${CFG}.tmp"

mv "${CFG}.tmp" "$CFG"
`, cfgPath, publicKey)

	removeCmd := exec.Command("docker", "exec", wgContainer, "sh", "-c", script)
	if out, err := removeCmd.CombinedOutput(); err != nil {
		return fmt.Errorf("failed to remove peer from %s: %v\nOutput:\n%s", cfgPath, err, string(out))
	}
	return nil
}

func pingFromWireGuard(ip string) error {
	cmd := exec.Command("docker", "exec", wgContainer, "sh", "-c",
		fmt.Sprintf("ping -c 1 -W 2 %s >/dev/null 2>&1", ip))
	return cmd.Run() // nil == success
}

func uiStatus(r MikroTikRow) string {
	if strings.EqualFold(r.Status, "DISABLED") || strings.EqualFold(r.Status, "DEACTIVATED") {
		return "Deactivated"
	}
	if r.SiteID.Valid && r.SiteID.String != "" {
		return "Associated"
	}
	return "Unassociated"
}

func handleMikrotikPreRegister(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodPost {
		http.Error(w, "Only POST allowed", http.StatusMethodNotAllowed)
		return
	}
	if !requireDB(w) {
		return
	}

	var req MikroTikRegisterRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		http.Error(w, "Invalid request body", http.StatusBadRequest)
		return
	}
	// Duplicate check
	var exists bool
	if err := db.QueryRow(`SELECT EXISTS (SELECT 1 FROM mikrotik_routers WHERE mac_address = $1)`, req.MAC).Scan(&exists); err != nil {
		http.Error(w, "Database error: "+err.Error(), http.StatusInternalServerError)
		return
	}
	if exists {
		http.Error(w, "MAC already registered", http.StatusConflict)
		return
	}

	data, err := MikroTikPreRegister(req.MAC)
	if err != nil {
		http.Error(w, "Pre-registration failed: "+err.Error(), http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	_ = json.NewEncoder(w).Encode(data)
}

func handleMikrotikList(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodGet {
		http.Error(w, "Only GET allowed", http.StatusMethodNotAllowed)
		return
	}
	if !requireDB(w) {
		return
	}

	items, err := listRouters()
	if err != nil {
		http.Error(w, "DB error: "+err.Error(), http.StatusInternalServerError)
		return
	}
	type Row struct {
		MAC    string  `json:"mac"`
		IP     string  `json:"ip"`
		Status string  `json:"status"`
		SiteID *string `json:"site_id"`
	}
	out := make([]Row, 0, len(items))
	for _, r := range items {
		var site *string
		if r.SiteID.Valid {
			site = &r.SiteID.String
		}
		out = append(out, Row{
			MAC: r.MAC, IP: r.IP, Status: uiStatus(r), SiteID: site,
		})
	}
	w.Header().Set("Content-Type", "application/json")
	_ = json.NewEncoder(w).Encode(out)
}

type testReq struct {
	MAC string `json:"mac"`
}

func handleMikrotikTest(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodPost {
		http.Error(w, "Only POST allowed", http.StatusMethodNotAllowed)
		return
	}
	if !requireDB(w) {
		return
	}

	var req testReq
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil || req.MAC == "" {
		http.Error(w, "Invalid request body", http.StatusBadRequest)
		return
	}
	rtr, err := getRouterByMAC(req.MAC)
	if err != nil {
		http.Error(w, "Not found", http.StatusNotFound)
		return
	}

	err = pingFromWireGuard(rtr.IP)
	resp := map[string]any{"ok": err == nil}
	w.Header().Set("Content-Type", "application/json")
	_ = json.NewEncoder(w).Encode(resp)
}

type macReq struct {
	MAC string `json:"mac"`
}

func handleMikrotikDisable(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodPost {
		http.Error(w, "Only POST allowed", http.StatusMethodNotAllowed)
		return
	}
	if !requireDB(w) {
		return
	}

	var req macReq
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil || req.MAC == "" {
		http.Error(w, "Invalid request body", http.StatusBadRequest)
		return
	}
	rtr, err := getRouterByMAC(req.MAC)
	if err != nil {
		http.Error(w, "Not found", http.StatusNotFound)
		return
	}

	if err := removeWireGuardPeer(rtr.PubKey); err != nil {
		http.Error(w, "WG remove error: "+err.Error(), http.StatusInternalServerError)
		return
	}
	if _, err := db.Exec(`UPDATE mikrotik_routers 
		SET provisioning_status='DISABLED', updated_at=now() WHERE mac_address=$1`, req.MAC); err != nil {
		http.Error(w, "DB update error: "+err.Error(), http.StatusInternalServerError)
		return
	}
	w.WriteHeader(http.StatusNoContent)
}

func handleMikrotikEnable(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodPost {
		http.Error(w, "Only POST allowed", http.StatusMethodNotAllowed)
		return
	}
	if !requireDB(w) {
		return
	}

	var req macReq
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil || req.MAC == "" {
		http.Error(w, "Invalid request body", http.StatusBadRequest)
		return
	}
	rtr, err := getRouterByMAC(req.MAC)
	if err != nil {
		http.Error(w, "Not found", http.StatusNotFound)
		return
	}

	if err := addWireGuardPeer(rtr.PubKey, rtr.IP); err != nil {
		http.Error(w, "WG add error: "+err.Error(), http.StatusInternalServerError)
		return
	}
	if _, err := db.Exec(`UPDATE mikrotik_routers 
		SET provisioning_status='ACTIVE', updated_at=now() WHERE mac_address=$1`, req.MAC); err != nil {
		http.Error(w, "DB update error: "+err.Error(), http.StatusInternalServerError)
		return
	}
	w.WriteHeader(http.StatusNoContent)
}

type associateReq struct {
	MAC    string `json:"mac"`
	SiteID string `json:"site_id"`
}

func handleMikrotikAssociate(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodPost {
		http.Error(w, "Only POST allowed", http.StatusMethodNotAllowed)
		return
	}
	if !requireDB(w) {
		return
	}

	var req associateReq
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil || req.MAC == "" || req.SiteID == "" {
		http.Error(w, "Invalid request body", http.StatusBadRequest)
		return
	}
	if _, err := db.Exec(`UPDATE mikrotik_routers 
		SET site_id=$1, updated_at=now() WHERE mac_address=$2`, req.SiteID, req.MAC); err != nil {
		http.Error(w, "DB update error: "+err.Error(), http.StatusInternalServerError)
		return
	}
	w.WriteHeader(http.StatusNoContent)
}

func handleMikrotikDelete(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodDelete {
		http.Error(w, "Only DELETE allowed", http.StatusMethodNotAllowed)
		return
	}
	if !requireDB(w) {
		return
	}

	var req macReq
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil || req.MAC == "" {
		http.Error(w, "Invalid request body", http.StatusBadRequest)
		return
	}
	rtr, err := getRouterByMAC(req.MAC)
	if err == nil && rtr.PubKey != "" {
		_ = removeWireGuardPeer(rtr.PubKey) // best-effort
	}
	if _, err := db.Exec(`DELETE FROM mikrotik_routers WHERE mac_address=$1`, req.MAC); err != nil {
		http.Error(w, "DB delete error: "+err.Error(), http.StatusInternalServerError)
		return
	}
	w.WriteHeader(http.StatusNoContent)
}
# URL API side prod : we pass through the Nginx proxy (/api -> backend:8000)
VITE_API_BASE_URL=/api
VUE_APP_API_BASE_URL=/api

# Optional : display the name in the UI
VITE_APP_NAME=NetSecure-IQ
NODE_ENV=development

# Backend exposed by docker compose on the host : http://localhost:8081
VITE_API_BASE_URL=http://localhost:8081/api
VUE_APP_API_BASE_URL=http://localhost:8081/api

VITE_APP_NAME=NetSecure-IQ (dev)
server {
  listen 80;
  server_name _;

  root /usr/share/nginx/html;
  index index.html index.htm;

  access_log /var/log/nginx/access.log main;
  error_log  /var/log/nginx/error.log warn;

  gzip on;
  gzip_types text/plain text/css application/javascript application/json application/xml text/javascript image/svg+xml;

  # Garde le /api dans lâ€™URI envoyÃ©e au backend
  location /api/ {
    proxy_pass http://backend:8000;   # <-- pas de slash final
    proxy_set_header Host              $host;
    proxy_set_header X-Real-IP         $remote_addr;
    proxy_set_header X-Forwarded-For   $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;
    proxy_http_version 1.1;
    proxy_set_header Connection "";
    client_max_body_size 20m;
    proxy_read_timeout 60s;
  }

  # SPA fallback
  location / {
    try_files $uri $uri/ /index.html;
    expires 1h;
  }
}
