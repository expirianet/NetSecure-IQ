// src/frontend/src/core/index.js// Regroupe: utils/api.js, utils/authApi.js, utils/agentsApi.js,// composables/useAuth.js, stores/authStore.js, stores/siteStore.js,// helpers/acl.js, utils/particles.js// -------------------------------// API base & HTTP helper// -------------------------------export const API =  (import.meta?.env?.VITE_API_BASE || '').replace(/\/+$/, '') ||  'http://localhost:8000';const defaultHeaders = { 'Content-Type': 'application/json' };export const authHeaders = () => {  const t = localStorage.getItem('token');  return t ? { Authorization: `Bearer ${t}` } : {};};async function http(method, path, body, extraHeaders = {}) {  const res = await fetch(`${API}${path}`, {    method,    headers: { ...defaultHeaders, ...authHeaders(), ...extraHeaders },    body: body != null ? JSON.stringify(body) : undefined,  });  let data = null;  try { data = await res.json(); } catch { /* no json body */ }  if (!res.ok) {    const msg = data?.error || data?.message || `HTTP ${res.status}`;    throw new Error(msg);  }  return data;}export const api = {  get: (p, h) => http('GET', p, undefined, h),  post: (p, b, h) => http('POST', p, b, h),  del: (p, b, h) => http('DELETE', p, b, h),};// -------------------------------// Domain APIs (auth / users / agents)// -------------------------------export const authApi = {  login: (email, password) => api.post('/api/login', { email, password }),  register: (email) => api.post('/api/register', { email }),  createUser: (payload) => api.post('/api/users', payload),  completeOrganization: (payload) =>    api.post('/api/complete-organization', payload),};export const agentsApi = {  list: () => api.get('/api/mikrotik/list'),  preregister: (mac) => api.post('/api/mikrotik/preregister', { mac }),  enable: (mac) => api.post('/api/mikrotik/enable', { mac }),  disable: (mac) => api.post('/api/mikrotik/disable', { mac }),  remove: (mac) => api.del('/api/mikrotik', { mac }),  test: (mac) => api.post('/api/mikrotik/test', { mac }),  associate: (mac, site_id) => api.post('/api/mikrotik/associate', { mac, site_id }),};// -------------------------------// Minimal ACL helper// -------------------------------export const acl = {  can(role, allowed) {    const r = (role || '').toLowerCase();    const list = Array.isArray(allowed) ? allowed : [allowed];    return list.map(String).map(s => s.toLowerCase()).includes(r);  }};// -------------------------------// Global auth/site state + composable// (remplace stores/* + composables/useAuth.js)// -------------------------------import { reactive, computed } from 'vue';const _auth = reactive({  token: localStorage.getItem('token') || '',  role: (localStorage.getItem('role') || '').toLowerCase(),  user_id: localStorage.getItem('user_id') || '',  organization_id: localStorage.getItem('organization_id') || '',});const _site = reactive({  organization_id: localStorage.getItem('organization_id') || '',});function syncAuthToLocal(data = {}) {  if ('token' in data) localStorage.setItem('token', data.token || '');  if ('user_id' in data) localStorage.setItem('user_id', data.user_id || '');  if ('role' in data) localStorage.setItem('role', (data.role || '').toLowerCase());  if ('organization_id' in data) localStorage.setItem('organization_id', data.organization_id || '');}export function useAuth() {  const isLoggedIn = computed(() => !!_auth.token);  async function login(email, password) {    const data = await authApi.login(email, password);    Object.assign(_auth, {      token: data.token || '',      role: (data.role || '').toLowerCase(),      user_id: data.user_id || '',      organization_id: data.organization_id || '',    });    syncAuthToLocal(_auth);    _site.organization_id = _auth.organization_id;    window.dispatchEvent(new Event('auth-changed'));    return data;  }  function logout() {    Object.assign(_auth, { token: '', role: '', user_id: '', organization_id: '' });    syncAuthToLocal(_auth);    _site.organization_id = '';    window.dispatchEvent(new Event('auth-changed'));  }  return { state: _auth, isLoggedIn, login, logout };}export const authStore = {  state: _auth,  setOrganization(id) {    _auth.organization_id = id || '';    _site.organization_id = _auth.organization_id;    localStorage.setItem('organization_id', _auth.organization_id);    window.dispatchEvent(new Event('auth-changed'));  }};export const siteStore = {  state: _site,  setOrganization(id) {    _site.organization_id = id || '';    localStorage.setItem('organization_id', _site.organization_id);    window.dispatchEvent(new Event('auth-changed'));  }};// -------------------------------// Particles utilities (remplace utils/particles.js)// -------------------------------export function ensurePJSDom() {  if (!window.pJSDom) window.pJSDom = [];  return window.pJSDom;}export function themeIsDark() {  // dÃ©faut: dark si pas explicitement 'light'  return document.documentElement.getAttribute('data-theme') !== 'light';}export function defaultConfig(isDark = true) {  const color = isDark ? '#00c2c2' : '#0ea5a5';  const linkColor = isDark ? '#22d3ee' : '#0ea5a5';  return {    particles: {      number: { value: 40, density: { enable: true, value_area: 800 } },      color: { value: color },      shape: { type: 'circle' },      opacity: { value: 0.2 },      size: { value: 3, random: true },      line_linked: { enable: true, distance: 150, color: linkColor, opacity: 0.2, width: 1 },      move: { enable: true, speed: 2, out_mode: 'out' }    },    interactivity: {      detect_on: 'canvas',      events: { onhover: { enable: false }, onclick: { enable: false }, resize: true }    },    retina_detect: true  };}export function loadParticlesScript() {  return new Promise((resolve, reject) => {    if (window.particlesJS) return resolve();    const id = 'particlesjs-cdn';    if (document.getElementById(id)) {      document.getElementById(id).addEventListener('load', resolve, { once: true });      return;    }    const s = document.createElement('script');    s.id = id;    s.src = 'https://cdn.jsdelivr.net/npm/particles.js@2.0.0/particles.min.js';    s.async = true;    s.onload = () => resolve();    s.onerror = (e) => reject(e);    document.head.appendChild(s);  });}export function destroyForId(containerId) {  try {    const list = ensurePJSDom();    for (let i = list.length - 1; i >= 0; i--) {      const inst = list[i];      const el = inst?.pJS?.canvas?.el?.parentNode || inst?.pJS?.canvas?.el;      if (!el) continue;      const same = (el.id === containerId);      if (same) {        // compat des versions        if (inst?.pJS?.fn?.vendors?.destroy) inst.pJS.fn.vendors.destroy();        if (inst?.pJS?.fn?.vendors?.destroypJS) inst.pJS.fn.vendors.destroypJS();        list.splice(i, 1);      }    }  } catch { /* ignore */ }}export function safeRender(containerId, config) {  if (!window.particlesJS || !document.getElementById(containerId)) return false;  destroyForId(containerId);  try {    window.particlesJS(containerId, config);    return true;  } catch {    return false;  }}export function observeTheme(containerId, renderFn) {  const mo = new MutationObserver(() => { renderFn(); });  mo.observe(document.documentElement, { attributes: true, attributeFilter: ['data-theme'] });  const onStorage = () => renderFn();  window.addEventListener('storage', onStorage);  return () => { mo.disconnect(); window.removeEventListener('storage', onStorage); };}
